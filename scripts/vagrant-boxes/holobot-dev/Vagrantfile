## Vagrantfile

# -----------------------------CONST--------------------------------------------
HOME = File.dirname(__FILE__)
HOME_SCRIPTS = "#{HOME}/../../../scripts" # make it explicit we are in scripts
HOME_BASE_BOX = "#{HOME}/../base-boxes"
HOME_NFS_MOUNT = "#{HOME_SCRIPTS}/nfs_mount"
HOME_LIB = "#{HOME_SCRIPTS}/lib"
HOME_CONF = "#{HOME_SCRIPTS}/conf"

REMOTE_NFS_MOUNT = '/mnt/holobot-nfs'
COMPILE_CUSTOM_ETCD = false

# relies on above (for now, and yes we need to split out project out into gems libs!)
require "#{HOME_LIB}/conf.rb" 
CONFIG = HoloConfig.new(HOME_CONF)


upgrade = <<SCRIPT
echo Running apt-get update and upgrade...
sudo apt-get update -y
#sudo apt-get upgrade -y
SCRIPT

installs = <<SCRIPT
echo "Installing basic tools via apt-get"
sudo apt-get install -y libssl-dev
SCRIPT

cleanup = <<SCRIPT
echo "Cleaning up apt-get cache..."
sudo apt-get clean
SCRIPT

restartNetworking = <<SCRIPT
# echo "Restarting networking"
# sudo ifdown -a
# sudo ifup -a
# echo "Sleeping 10 seconds, waiting for networking..."
# sleep 10
SCRIPT

strider = <<SCRIPT
echo "Installing strider via Docker..."
sudo docker pull strider/strider
sudo docker run -d -p 3000:3000 strider/strider
SCRIPT

mesos = <<SCRIPT
echo "Installing Mesos..."
curl -fL https://raw.github.com/mesosphere/mesos-docker/master/bin/mesos-docker-setup | sudo bash
SCRIPT

registry = <<SCRIPT
## local source dir is default location
## export DOCKER_REGISTRY_CONFIG=config.yml
# export SETTINGS_FLAVOR=dev
# cd /mnt/holobot-nfs/docker-registry
# sudo docker build .
echo "Running docker-registry docker container..."
sudo docker pull samalba/docker-registry
sudo docker run -d -p 5000:5000 samalba/docker-registry
echo "Checking for docker-registry response:"
curl -L http://10.10.10.10:5000/v1/_ping
SCRIPT

etcd_binary_linux = 'etcd-holobot-linux.tar.bz2'
replace_etcd_ubuntu = <<SCRIPT
echo "Compiling etcd for linux and saving to nfs mount..."
# First compile etcd for linux and then package it for future use
cd #{REMOTE_NFS_MOUNT}/etcd/etcd && ./build && tar -cvjf #{REMOTE_NFS_MOUNT}/etcd/#{etcd_binary_linux} etcd

# Stopping and remove cache
echo "Stopping etcd..."

echo "Removing etcd cache..."
sudo rm -R /var/cache/etcd

# Copy files necessary to make etcd work
echo "Unpacking and moving etcd binary"
sudo tar -xvf #{REMOTE_NFS_MOUNT}/etcd/#{etcd_binary_linux} -C /usr/local/bin

echo "Copying custom config file"
sudo cp #{REMOTE_NFS_MOUNT}/etcd/etcd.conf /etc/init/etcd.conf

echo "Restarting etcd..."
sudo service etcd start
SCRIPT

# Move this out to a databag or even better, a yaml file
# (yaml so we don't completely rely on vagrant or chef)
props = {
  :appname => CONFIG.get('version'),
  :scripts => {
    :upgrade => upgrade,
    :installs => installs,
    :cleanup => cleanup,
    :restartNetworking => restartNetworking,
    :strider => strider,
    :mesos => mesos,
    :registry => registry,
    :replace_etcd_ubuntu => replace_etcd_ubuntu
  }, # end scripts
  :chef => {
    :json => { 
      # Override default attributes here.
      'scala' => {
        'version' => '2.10.2',
        'url' => "http://www.scala-lang.org/files/archive/scala-2.10.2.tgz"
      },
      'go' => {
        'version' => '1.1.2'
      },
      'etcd' => {
        'version' => '0.1.1'
      },
      'nodejs' => {
        'version' => '0.10.18',
      }
      # 'nvm' => {
      #   'user' => 'vagrant',
      #   'nodes' => [
      #     'version' => '0.10.18',
      #     'alias' => 'default',
      #     'modules' => [
      #       { 'name' => 'grunt-cli'},
      #       { 'name' => 'httpster'},
      #     ]
      #   ]
      # }
    } # end json
  } # end chef
} # end props


#------------------------------METHODS------------------------------------------

def baseNode(os_name)
  CONFIG.get('machines')[os_name][CONFIG.mode]
end

def baseOSNode(os_name)
  CONFIG.get('machines')[os_name]
end

def prepare(config, props)
  # puts "Sleeping 10 seconds to wait for networking..."

  # installs
  config.vm.provision :shell, inline: props[:scripts][:restartNetworking]

  # sleep 10 # let vm networking catch up

  config.vm.provision :shell, inline: props[:scripts][:upgrade]
  config.vm.provision :shell, inline: props[:scripts][:installs]
end

def finishMessage(config, props, os_name)
  config.vm.provision :shell, inline: "echo '#{props[:appname]}-#{os_name} started...'"
end

def strider(config, props)
  # installs
  config.vm.provision :shell, inline: props[:scripts][:strider]
end

def mesos(config, props)
  # installs
  config.vm.provision :shell, inline: props[:scripts][:mesos]
end

def registry(config, props)
  # installs
  config.vm.provision :shell, inline: props[:scripts][:registry]
end
  
def runChef(config, props)
  # chef
  config.omnibus.chef_version = :latest #Define omnibus client to utilize

  config.vm.provision "chef_solo" do |chef|
    chef.log_level = :debug
    chef.cookbooks_path = [
      "#{HOME_SCRIPTS}/berkshelf", 
      "#{HOME_SCRIPTS}/cookbooks"
    ]

    # chef.data_bags_path = "#{HOME_SCRIPTS}/data_bags"

    chef.json = props[:chef][:json]

    # os
    chef.add_recipe "apt" # make sure this is always first!!!
    chef.add_recipe "build-essential" # make sure this is always second!!!
       
    # simple
    chef.add_recipe "python"
    chef.add_recipe "golang"
    chef.add_recipe "nodejs"
    
    # finally end with these installs resulting in systemic changes
    chef.add_recipe "docker" # though this does get installed by mesos!
    chef.add_recipe "etcd"

    # long running
    chef.add_recipe "java"
    chef.add_recipe "scala"
  end

  # config.berkshelf.enabled = true
end

def cleanup(config, props)
  config.vm.provision :shell, inline: props[:scripts][:cleanup]
end

def network(os_name, config, props)
  # Network
  node_mac = baseNode(os_name)['mac']
  private_ip = baseNode(os_name)['private_ip']

  config.vm.network :private_network, ip: private_ip#, :adapter => 2 # assigned to adapter 2 by default

  if (CONFIG.arch == 64)
    # the main card configuration
    config.vm.network :public_network, :bridge => 'en0: Wi-Fi (AirPort)', :mac => node_mac#, :adapter => 3
  else
    # yes we are actually specifying adapter 3 in 32 arch
    config.vm.network :public_network, :bridge => 'en0: Wi-Fi (AirPort)', :mac => node_mac, :adapter => 3
  end

  #config.ssh.username = 'core'
  #config.ssh.forward_agent = true
  #config.ssh.timeout = 500
  #config.ssh.max_tries = 40
end

def mounts(config, props)
  # NFS Mount 
  # disabled
  config.vm.synced_folder HOME_NFS_MOUNT, REMOTE_NFS_MOUNT, id: "vagrant-root", :nfs => true # requires root privs
end

def hypervisor_settings(os_name, config, props)
  # Vbox specific configs, should think about removing these
  mem = baseOSNode(os_name)['mem']

  config.vm.provider :virtualbox do |vb|
    puts "Using #{CONFIG.get('arch')}bit arch settings..."
    
    vb.customize ["modifyvm", :id, "--cpus", "1"] #making sure cpus are accounted at min
    # vb.customize ["modifyvm", :id, "--cpuexecutioncap", 50]
    vb.customize ["modifyvm", :id, "--memory", mem] #min ram to build box
    
    if (CONFIG.get('arch') == 64)
      # vb.customize ["modifyvm", :id, "--ioapic", "on"]
      # vb.customize ["modifyvm", :id, "--acpi", "off"]
      vb.customize ["modifyvm", :id, "--hwvirtex", "on"] #in case it is needed
    
      # by default pae is on! Turning it off will force the vm to switch PAE modes DURING boot
      # which is NOT recommended, this is a bug for sure!
      vb.customize ["modifyvm", :id, "--pae", "on"]

      # vb.customize ["modifyvm", :id, "--rtcuseutc", "on"] # should be on by default
    else
      puts "Using 32bit arch settings..."
      vb.customize ["modifyvm", :id, "--ioapic", "off"]
      vb.customize ["modifyvm", :id, "--hwvirtex", "off"]
      vb.customize ["modifyvm", :id, "--rtcuseutc", "on"]
    end

    # vb.gui = true #just in case
  end
end


#------------------------------MAIN---------------------------------------------

# Plugins
#Vagrant.require_plugin 'vagrant-vbguest'
#Vagrant.require_plugin 'vagrant-berkshelf'
#Vagrant.require_plugin 'vagrant-omnibus'

Vagrant.configure("2") do |config|

  config.vm.define "ubuntu", primary: true do |ubuntu|
    os_name = "ubuntu"

    # Base setup
    ubuntu.vm.box = "#{props[:appname]}-#{os_name}"

    # config.vm.box_url = 'http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box'
    ubuntu.vm.box_url = "#{HOME_BASE_BOX}/#{os_name}_13_04_lts.box"
    # In a purely functional lang I would curry and compose the below. Ruby?
    hypervisor_settings(os_name, ubuntu, props)
    network(os_name, ubuntu, props)
    mounts(ubuntu, props)
    prepare(ubuntu, props)
    runChef(ubuntu, props)
    mesos(ubuntu, props)

    # replace etcd, only needed if etcd version is NOT up to date
    if (COMPILE_CUSTOM_ETCD)
      ubuntu.vm.provision :shell, inline: props[:scripts][:replace_etcd_ubuntu]
    end

    cleanup(ubuntu, props)
    finishMessage(ubuntu, props, os_name)
  end

  config.vm.define "coreos" do |coreos|
    os_name = "ubuntu"

    # Base setup
    coreos.vm.box = "#{props[:appname]}-#{os_name}"

    coreos.vm.box_url = "#{HOME_BASE_BOX}/#{os_name}_production_vagrant.box"
    hypervisor_settings(os_name, coreos, props)
    network(os_name, coreos, props)
    mounts(coreos, props)
    runChef(coreos, props)
    cleanup(coreos, props)
    finishMessage(coreos, props, os_name)
  end

  config.vm.define "strider", primary: true do |strider|
    os_name = "strider"
    # Base setup
    strider.vm.box = "#{props[:appname]}-#{os_name}"

    # config.vm.box_url = 'http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box'
    strider.vm.box_url = "#{HOME_BASE_BOX}/ubuntu_13_04_lts.box"
    # In a purely functional lang I would curry and compose the below. Ruby?
    hypervisor_settings(os_name, strider, props)
    network(os_name, strider, props)
    mounts(strider, props)
    prepare(strider, props)
    runChef(strider, props)

    # replace etcd, only needed if etcd version is NOT up to date
    if (COMPILE_CUSTOM_ETCD)
      strider.vm.provision :shell, inline: props[:scripts][:replace_etcd_ubuntu]
    end

    cleanup(strider, props)
    strider(strider, props)
    finishMessage(strider, props, os_name)
  end

  config.vm.define "registry", primary: true do |box|
    os_name = "registry"
    # Base setup
    box.vm.box = "#{props[:appname]}-#{os_name}"

    # config.vm.box_url = 'http://cloud-images.ubuntu.com/vagrant/raring/current/raring-server-cloudimg-amd64-vagrant-disk1.box'
    box.vm.box_url = "#{HOME_BASE_BOX}/ubuntu_13_04_lts.box"
    # In a purely functional lang I would curry and compose the below. Ruby?
    hypervisor_settings(os_name, box, props)
    network(os_name, box, props)
    mounts(box, props)
    prepare(box, props)
    runChef(box, props)

    # replace etcd, only needed if etcd version is NOT up to date
    if (COMPILE_CUSTOM_ETCD)
      box.vm.provision :shell, inline: props[:scripts][:replace_etcd_ubuntu]
    end

    cleanup(box, props)
    registry(box, props)
    finishMessage(box, props, os_name)
  end
end