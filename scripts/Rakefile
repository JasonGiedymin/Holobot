# Holobot Rakefile
#
# `rake` for usage
#

## require
require 'rake/clean'


# Immediately sync all stdout so that tools like buildbot can
# immediately load in the output.
$stdout.sync = true
$stderr.sync = true


## init
# Change to the directory of this file.
Dir.chdir(File.expand_path("../", __FILE__))


## consts
HOME = File.dirname(__FILE__)
COOKBOOKS_DIR = "#{HOME}/cookbooks"
BERKSHELF_DIR = "#{HOME}/berkshelf"
THIRDPARTY_DIR = "#{HOME}/thirdparty"
BASE_BOX_DIR = "#{HOME}/../vagrant-boxes/base-boxes"

CLEAN = FileList[
  "#{COOKBOOKS_DIR}/*",
  "./Berksfile",
  "./Berksfile.lock",
  "./berkshelf",
  "./thirdparty",
  "./Thorfile",
  "./.git",
  "./Vagrantfile"
].exclude("#{COOKBOOKS_DIR}/README.md")

# Do not use, use gemfile instead
BASE_GEM_INSTALL_LIST = [
  #"vagrant", # gem bundle version is out of date, do manual install :-()
  #"berkshelf"
]

BASE_VAGRANT_PLUGINS = [
  # "vagrant-vbguest",
  "vagrant-berkshelf",
  "vagrant-omnibus"
]

BASE_BOX_URLS = {
  :ubuntu_12_04_lts => {
    'track' => false, # if already exists, skips
    'url' => 'http://files.vagrantup.com/precise64.box'
  },
  :coreos_production_vagrant => {
    'track' => true, # will track meaning always download
    'url' => 'http://storage.core-os.net/coreos/amd64-generic/dev-channel/coreos_production_vagrant.box'
  }
}

THIRD_PARTY = {
  "docker" => "https://github.com/dotcloud/docker.git"
}


## Tasks
task :default do
  Rake::Task["help:examples"].invoke
end

namespace :baseboxes do
  def curl(name, url)
    puts "Downloading base box [ #{name} via #{url} ]"
    if system "curl #{url} > #{BASE_BOX_DIR}/#{name}.box"
      puts "-> Base box #{name} downloaded.\n\n"
    else
      raise "\n!!!\n   Error downloading base box: #{url}\n!!!\n\n"
    end
  end

  desc "Update base boxes"
  task :download do
    BASE_BOX_URLS.each_pair do |name, box_info|
      # If the file doesn't exist get it
      # otherwise if it does already exist
      # then only get it if tracking is enabled
      if !File.exists?("#{BASE_BOX_DIR}/#{name}.box")
        curl(name, box_info['url'])
      else # File exists, but only get if tracking is on
        curl(name, box_info['url']) if box_info['track']
      end
    end
  end
end

# Base namespace
namespace :cookbooks do
  def clone(name, url, dir)
    puts "Cloning cookbook [ #{name} via #{url} ]"
    if system "git clone #{url} #{dir}/#{name}"
      puts "-> Repository #{url} cloned.\n\n"
    else
      raise "\n!!!\n   Error cloning url: #{url}\n!!!\n\n"
    end
  end

  def berksInstall(name)
    puts "Adding to berkshelf [ #{name} ]"
    if File.exists?("#{COOKBOOKS_DIR}/#{name}/Berksfile")
      if system "cd #{COOKBOOKS_DIR}/#{name} && berks install --path #{BERKSHELF_DIR}"
        puts "-> cookbook #{name} added to berkshelf.\n\n"
      else
        raise "\n!!!\n   Error adding to berkshelf: #{name}\n!!!\n\n"
      end
    end
  end

  desc "Manual Update of a remote cookbook"
  task :manual, :name, :url do |t, args|
    puts "Updating remote cookbooks"
    name = args[:name]
    url = args[:url]
    clone(name, url, COOKBOOKS_DIR)    
  end

  desc "Clones all known remote cookbooks"
  task :clone do
    cookbooks = {
      :apt => "https://github.com/opscode-cookbooks/apt.git",
      :ark => "https://github.com/opscode-cookbooks/ark.git",
      :"build-essential" => "https://github.com/opscode-cookbooks/build-essential.git",
      :dpkg_autostart => "https://github.com/hw-cookbooks/dpkg_autostart",
      :dmg => "https://github.com/opscode-cookbooks/dmg.git",
      :docker => "https://github.com/bflad/chef-docker.git",
      :etcd => "https://github.com/spheromak/etcd-cookbook.git",
      :git => "https://github.com/opscode-cookbooks/git.git",
      :golang => "https://github.com/NOX73/chef-golang.git",
      :java => "https://github.com/opscode-cookbooks/java.git",
      :lxc => "https://github.com/hw-cookbooks/lxc.git",
      :modules => "https://github.com/Youscribe/modules-cookbook.git",
      :nodejs => "https://github.com/mdxp/nodejs-cookbook.git",
      :nvm => "https://github.com/hipsnip-cookbooks/nvm.git",
      :python => "https://github.com/opscode-cookbooks/python.git",
      :runit => "https://github.com/opscode-cookbooks/runit.git",
      :scala => "https://github.com/RiotGames/scala-cookbook.git",
      :windows => "https://github.com/opscode-cookbooks/windows.git",
      :yum => "https://github.com/opscode-cookbooks/yum.git"
    }
    puts "Running clone..."

    cookbooks.each_pair do |name, url|
      clone(name, url, COOKBOOKS_DIR)
      berksInstall(name) #disabled for now
    end

  end
end


# NOT WORKING
# Revisit some day
# namespace :vagrant do
#   def up()
#     if system "vagrant up"
#     else
#       raise "\n!!!\n   Error trying to vagrant up\n!!!\n\n"
#     end
#   end

#   def destroy()
#     if system "vagrant destroy --force"
#     else
#       raise "\n!!!\n   Error trying to destroy vagrant litter\n!!!\n\n"
#     end
#   end

#   def navToVagrant()
#     Dir.chdir(File.expand_path("../../vagrant-boxes/holobot-dev", "Vagrantfile"))
#   end

#   desc "up"
#   task :up do
#     navToVagrant()
#     up()
#   end

#   desc "destroy"
#   task :destroy do
#     navToVagrant()
#     destroy()
#   end
# end

namespace :thirdparty do
  desc "Clone third-party software (docker, etc...)"
  task :clone do
    Rake::Task["clobber"].invoke

    THIRD_PARTY.each_pair do |name, url|
      clone(name, url, THIRDPARTY_DIR)
    end
  end
end

# Install namespace for setting up base environment
namespace :install do
  def installGem(gemName)
    puts "gem install [ #{gemName} ]"
    if system "gem install #{gemName}"
      puts "-> Installed #{gemName}...\n\n"
    else
      raise "\n!!!\n   Error trying to gem install #{gemName}\n!!!\n\n"
    end
  end

  def installVagrantPlugin(pluginName)
    system "vagrant --version"
    puts "vagrant plugin install [ #{pluginName} ]"
    if system "vagrant plugin install #{pluginName}"
      puts "-> Installed vagrant plugin #{pluginName}...\n\n"
    else
      raise "\n!!!\n   Error trying to vagrant plugin install #{pluginName}\n!!!\n\n"
    end
  end

  # def bindlerSetup()
  #   if system "vagrant bindler setup"
  #     puts "-> bindler setup done...\n\n"
  #   else
  #     raise "\n!!!\n   Error trying to run bindler setup\n!!!\n\n"
  #   end
  # end

  # AVOID BINDLER - TOO MUCH MONKEY PATCHING!
  # bindler is bundler for vagrant, it will install vagrant plugins specified from plugins.json
  # def bindlerRun()
  #   if system "vagrant plugin bundle"
  #     puts "-> installing vagrant plugins...\n\n"
  #   else
  #     raise "\n!!!\n   Error trying to install vagrant plugins\n!!!\n\n"
  #   end
  # end

  desc "Install gems for Holobot"
  task :gems do
    #puts "Installing gems for Holobot..."
    puts "!USE Gemfile instead!!!"
    puts "run:"
    puts "    bundle install"
    #BASE_GEM_INSTALL_LIST.each{ |gemName| installGem(gemName) }
  end

  desc "Install deps for Holobot"
  task :deps do
    BASE_VAGRANT_PLUGINS.each{ |plugin| installVagrantPlugin(plugin) }
  end

  desc "Full auto install."
  task :auto do
    Rake::Task["clobber"].invoke
    Rake::Task["baseboxes:download"].invoke
    Rake::Task["cookbooks:clone"].invoke
    Rake::Task["install:deps"].invoke
    Rake::Task["thirdparty:clone"].invoke

    puts "\nFull auto install complete!"
  end
end

namespace :help do
  desc "usage examples"
  task :examples do
    puts "\n\n"
    puts " Note: You may see `CLEAN` warnings from running `rake`, you may safely ignore these."
    puts "---------------------------"
    puts " Usage Examples:"
    puts "  `rake -T` lists all the available tasks"
    puts "  `rake clean` cleans up cookbooks and misc files"
    puts "  `rake cookbooks:clone` will autoupdate cookbooks by cloning into cookbooks/"
    puts "  `rake cookbooks:manual['java','https://github.com/opscode-cookbooks/java.git']` to manually clone a cookbook"
    puts "---------------------------"
    puts "\n\n"
  end

  task :default => :examples
end

